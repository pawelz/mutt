diff -Nur mutt-1.3.25-2/curs_main.c mutt-1.3.25/curs_main.c
--- mutt-1.3.25-2/curs_main.c	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/curs_main.c	Tue Jan 22 00:07:02 2002
@@ -546,7 +546,7 @@
 	  menu_redraw_current (menu);
       }
 
-      if (menu->redraw & REDRAW_STATUS) 
+      if ((menu->redraw & REDRAW_STATUS) || update_status_time ())
       {
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
 	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
diff -Nur mutt-1.3.25-2/globals.h mutt-1.3.25/globals.h
--- mutt-1.3.25-2/globals.h	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/globals.h	Tue Jan 22 00:07:02 2002
@@ -145,6 +145,7 @@
 WHERE short ReadInc;
 WHERE short SendmailWait;
 WHERE short SleepTime INITVAL (1);
+WHERE short StatusUpdate;
 WHERE short Timeout;
 WHERE short WrapMargin;
 WHERE short WriteInc;
diff -Nur mutt-1.3.25-2/init.h mutt-1.3.25/init.h
--- mutt-1.3.25-2/init.h	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/init.h	Tue Jan 22 00:09:07 2002
@@ -2119,6 +2119,9 @@
   ** .dt %u  .dd number of unread messages *
   ** .dt %v  .dd Mutt version string
   ** .dt %V  .dd currently active limit pattern, if any *
+  ** .dt %[fmt] .dd the current date and time. ``fmt'' is
+  **                expanded by the system call ``strftime'';
+  **                a leading bang disables locales 
   ** .dt %>X .dd right justify the rest of the string and pad with "X"
   ** .dt %|X .dd pad to the end of the line with "X"
   ** .de
@@ -2160,6 +2163,16 @@
   ** Setting this variable causes the ``status bar'' to be displayed on
   ** the first line of the screen rather than near the bottom.
   */
+  { "status_update",  DT_NUM, R_NONE, UL &StatusUpdate, -1 },
+  /*
+  ** .pp
+  ** This variable controls, if positive, the maximum interval in seconds
+  ** before the time in the status line is updated. It is checked at
+  ** every key press and after a keyboard $$timeout.
+  ** If the value is zero, the status line will be updated at every check.
+  ** If it is negative, the status time will only be updated
+  ** if it necessary to update to the status line for some other reason.
+  */
   { "strict_threads",	DT_BOOL, R_RESORT|R_RESORT_INIT|R_INDEX, OPTSTRICTTHREADS, 0 },
   /*
   ** .pp
diff -Nur mutt-1.3.25-2/menu.c mutt-1.3.25/menu.c
--- mutt-1.3.25-2/menu.c	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/menu.c	Tue Jan 22 00:07:02 2002
@@ -1045,3 +1045,23 @@
   }
   /* not reached */
 }
+
+int update_status_time ()
+{
+  static time_t Last;
+  time_t now;
+
+  if (StatusUpdate < 0)
+    return 0;
+  else if (StatusUpdate == 0)
+    return 1;
+
+  now = time (NULL);
+  if (now - Last >= StatusUpdate)
+  {
+    Last = now;
+    return 1;
+  }
+  else
+    return 0;
+}
diff -Nur mutt-1.3.25-2/mutt_menu.h mutt-1.3.25/mutt_menu.h
--- mutt-1.3.25-2/mutt_menu.h	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/mutt_menu.h	Tue Jan 22 00:07:02 2002
@@ -107,3 +107,5 @@
 /* used in both the index and pager index to make an entry. */
 void index_make_entry (char *, size_t, struct menu_t *, int);
 int index_color (int);
+
+int update_status_time (void);
diff -Nur mutt-1.3.25-2/pager.c mutt-1.3.25/pager.c
--- mutt-1.3.25-2/pager.c	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/pager.c	Tue Jan 22 00:07:02 2002
@@ -1712,7 +1712,7 @@
       SETCOLOR (MT_COLOR_NORMAL);
     }
 
-    if ((redraw & REDRAW_INDEX) && index)
+    if (index && ((redraw & REDRAW_INDEX) || update_status_time ()))
     {
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
diff -Nur mutt-1.3.25-2/status.c mutt-1.3.25/status.c
--- mutt-1.3.25-2/status.c	Tue Jan 22 00:06:44 2002
+++ mutt-1.3.25/status.c	Tue Jan 22 00:07:02 2002
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <ctype.h>
 #include <unistd.h>
+#include <locale.h>
 
 static char *get_sort_str (char *buf, size_t buflen, int method)
 {
@@ -284,6 +285,61 @@
       *buf = 0;
       return (src);
 
+    case '[':
+      {
+	int do_locales;
+	int len = sizeof (fmt) - 1;
+
+	cp = fmt;
+	if (*src == '!')
+	{
+	  do_locales = 0;
+	  src++;
+	}
+	else
+	  do_locales = 1;
+
+	while (len > 0 && *src != ']')
+	{
+	  if (*src == '%')
+	  {
+	    src++;
+	    if (len >= 2)
+	    {
+	      *cp++ = '%';
+	      *cp++ = *src;
+	      len -= 2;
+	    }
+	    else
+	      break; /* not enough space */
+	    src++;
+	  }
+	  else
+	  {
+	    *cp++ = *src++;
+	     len--;
+	  }
+	}
+	*cp = 0;
+	src++;
+
+	if (do_locales && Locale)
+	  setlocale (LC_TIME, Locale);
+
+	{
+	  time_t now = time (NULL);
+
+	  strftime (tmp, sizeof (tmp), fmt, localtime (&now));
+	}
+
+	if (do_locales && Locale)
+	  setlocale (LC_TIME, "C");
+
+	snprintf (fmt, sizeof (fmt), "%%%ss", prefix);
+	snprintf (buf, buflen, fmt, tmp);
+      }
+      break;
+
     default:
       snprintf (buf, buflen, "%%%s%c", prefix, op);
       break;

