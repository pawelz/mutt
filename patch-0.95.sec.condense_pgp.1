--- mutt-1.1.11.orig/init.h	Sun Apr  2 23:40:02 2000
+++ mutt-1.1.11/init.h	Sun Apr  2 23:41:08 2000
@@ -1169,6 +1169,7 @@
   ** lead to problems with non-verifyable PGP signatures, so only change
   ** this if you know what you are doing.
   */
+  { "pgp_paranoid",	DT_BOOL, R_NONE, OPTPGPPARANOID, 0 },
   { "pgp_timeout",	DT_NUM,	 R_NONE, UL &PgpTimeout, 300 },
   /*
   ** .pp
--- mutt-0.95/mutt.h.orig	Sat Dec 12 09:06:47 1998
+++ mutt-0.95/mutt.h	Sun Jan  3 03:39:19 1999
@@ -309,6 +309,7 @@
   OPTMHPURGE,
   OPTMIMEFORWDECODE,
   OPTPAGERSTOP,
+  OPTPGPPARANOID,
   OPTPIPEDECODE,
   OPTPIPESPLIT,
   OPTPOPDELETE,
--- mutt-0.95/patchlist.c.orig	Sun Jan  3 03:11:41 1999
+++ mutt-0.95/patchlist.c	Sun Jan  3 03:39:19 1999
@@ -16,6 +16,8 @@
 
 
 
+  printf("Feature patch: condense_pgp         0.95   by Stefan `Sec` Zehl\n");
+
 
 
   /* DO NOT MODIFY AFTER THIS LINE */
--- mutt-0.95/pgp.c.orig	Sat Dec 12 09:07:00 1998
+++ mutt-0.95/pgp.c	Sun Jan  3 03:41:29 1999
@@ -216,6 +216,102 @@
 }
 
 
+/*
+ * Scan PGP output; return information about state of signature.
+ * Flush the message (on stdout).
+ *
+ * If strat==0, the message is piped to PGP on stdin, the verified
+ * message is output on stdout, and runtime messages are on stderr.
+ * If strat==1, the message comes from a file, and the runtime
+ * messages are on stdout.
+ */
+
+int
+mutt_scan_pgp_output (FILE *infile, FILE *outfile, STATE *outstate)
+{
+  int sigstate=0, pgpwarning=0;
+  int nl=0;
+  char buffer[LONG_STRING];
+
+  while (fgets (buffer, sizeof(buffer), infile) != NULL) {
+    if (strncmp (buffer, "Good signature", 14) == 0)
+      if (sigstate!=3)
+	sigstate=1;
+    if (strncmp (buffer, "WARNING", 7)    == 0 &&
+	strstr  (buffer, "not certified") != NULL)
+      if (sigstate!=3)
+	sigstate=2;
+    if (strncmp (buffer, "Bad signature", 13) == 0)
+      sigstate=3;
+    if (strncmp (buffer, "\007Key matching", 13) == 0 &&
+	strstr  (buffer, "not found")            != NULL)
+      if (sigstate!=3)
+	sigstate=4;
+    if (strncmp (buffer, "WARNING", 7) == 0)
+      pgpwarning|=1;
+    if (strncmp (buffer, "\007WARNING", 7) == 0)
+      pgpwarning|=1;
+    if (strncmp (buffer, "Error", 5) == 0)
+      pgpwarning|=2;
+    if (strncmp (buffer, "\007Error", 5) == 0)
+      pgpwarning|=2;
+
+    /* pgp2 */
+    if (strncmp(buffer, "\007Key matching", 13) == 0 &&
+        strstr (buffer, "not found") != NULL)
+      continue;
+    if (strncmp(buffer, "File '", 6) == 0 &&
+	strstr (buffer, "has signature, but with no text") != NULL)
+      continue;
+    if (strncmp(buffer, "Text is assumed to be in file '", 31) == 0)
+      continue;
+    /* pgp5 */
+    if (strncmp(buffer, "No files specified.  Using stdin.", 33) == 0)
+      continue;
+    if (strncmp(buffer, "Opening file \"stdout\" type text.", 32) == 0)
+      continue;
+    if (strncmp(buffer, "Message is encrypted.", 21) == 0)
+      continue;
+    /* pgp5 bogon makes pgp2 warn */
+    if (strncmp(buffer, "Warning",7) == 0 &&
+	strstr (buffer, "header label \"MessageID:\" ignored") != NULL)
+      continue;
+
+    if(buffer[0]=='\n'){
+	if(nl)continue;
+	nl=1;
+    }else{
+	nl=0;
+    }
+    if (outstate) {
+      if (strlen(buffer)>2 && buffer[strlen(buffer)-2]=='\007')
+	buffer[strlen(buffer)-2]=' ';
+      else if (strlen(buffer)>3 && buffer[strlen(buffer)-3]=='\007')
+	buffer[strlen(buffer)-3]=' ';
+
+      if (buffer[0] == '\007') {
+	state_puts(buffer+1, outstate);
+      }
+      else {
+	state_puts(buffer, outstate);
+      }
+    }
+    if (outfile) {
+      if (buffer[0] == '\007') {
+	fputs(buffer+1, outfile);
+      }
+      else {
+	fputs(buffer, outfile);
+      }
+    }
+  }
+  
+  sigstate |= (pgpwarning<<4);
+
+  return sigstate;
+}
+ 
+
 /* Support for the Application/PGP Content Type. */
 
 void application_pgp_handler (BODY *m, STATE *s)
@@ -334,7 +430,10 @@
 	fclose (pgpin);
 	
 	if (s->flags & M_DISPLAY)
+	  if(option(OPTPGPPARANOID))
 	  pgp_current_time (s);
+	  else
+	    mutt_scan_pgp_output(pgperr,NULL,s);
 	
 	mutt_wait_filter (thepid);
 
@@ -345,17 +444,17 @@
 	fclose (pgperr);
 	
 	if (s->flags & M_DISPLAY)
-	  state_puts (_("\n[-- End of PGP output --]\n\n"), s);
+	  state_puts (_("\n[-- End of PGP output --"), s);
       }
     
       if(s->flags & M_DISPLAY)
       {
 	if (needpass)
-	  state_puts (_("[-- BEGIN PGP MESSAGE --]\n\n"), s);
+	  state_puts ("BEGIN PGP MESSAGE --]\n\n", s);
 	else if (pgp_keyblock)
-	  state_puts (_("[-- BEGIN PGP PUBLIC KEY BLOCK --]\n"), s);
+	  state_puts ("BEGIN PGP PUBLIC KEY BLOCK --]\n", s);
 	else
-	  state_puts (_("[-- BEGIN PGP SIGNED MESSAGE --]\n\n"), s);
+	  state_puts ("BEGIN PGP SIGNED MESSAGE --]\n\n", s);
       }
 
       /* Use PGP's output if there was no clearsig signature. */
diff -Nru mutt-1.1.11.orig/pgp.c mutt-1.1.11/pgp.c
--- mutt-1.1.11.orig/pgp.c	Sun Apr  2 23:49:51 2000
+++ mutt-1.1.11/pgp.c	Sun Apr  2 23:51:58 2000
@@ -678,7 +678,10 @@
 				   -1, -1, fileno(pgperr),
 				   tempfile, sigfile)) != -1)
   {
+ 	 if(option(OPTPGPPARANOID))
     mutt_copy_stream(pgpout, s->fpout);
+ 	 else
+ 	 mutt_scan_pgp_output(pgpout,NULL,s);
     fclose (pgpout);
     fflush(pgperr);
     rewind(pgperr);
